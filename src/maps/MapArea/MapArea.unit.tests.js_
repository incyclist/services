import MapArea, {getVector, initialBearingTo,alongTrackDistanceTo,destinationPoint, 
                 getCrossingInfo, _getPointOnLine, getPointCrossingPath, splitAtPoint, findAdditional, isAllowed,
                 collectRoundabout,isRoundabout                
                }  from './MapArea';
import OverpassClient from '../overpass/OverpassClient';
import { distanceBetween } from '../../geo/GeoUtils';
import fs from 'fs';

console.log = jest.fn();

require("jest-json");
jest.mock('../overpass/OverpassClient');

function decodePath(path) {
    return path.map( v=>v.id ).join(',');
}
function decodeArray(path) {
    return path.join(',');
}
function p (lat,lng) {
    return { lat,lng}
}


describe ( 'constructor', () => {
    let expected = fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
    let expectedQuery = '[out:json];way[highway](-16.78313012049534,145.69732051718006,-16.781333479504664,145.69919708281992);(._;>;);out geom;';
    const defSetLocation = MapArea.prototype.setLocation
    const setLocationMock = jest.fn();

    const runTest = async (props,mocks) => {
        if ( mocks!==undefined && mocks.setLocation!==undefined)
            MapArea.prototype.setLocation = mocks.setLocation;
        let b = new MapArea(props);        
        return b    
    }

    beforeEach( ()=> {

        OverpassClient.mockImplementation( () => {
            return  {
                query: (query) => new Promise ( (resolve,reject) => { 
                    if ( query===expectedQuery) {
                        resolve(expected)
                    }
                    else {
                        reject("some error");
                    }
                }) 
            }
        })
    });

    afterEach( () => {
        OverpassClient.mockClear();
        MapArea.prototype.setLocation = defSetLocation;
    })

    test ( 'no arguments', async () => {
        
        let a = await runTest(undefined,{setLocation:setLocationMock} );
        expect(setLocationMock).not.toHaveBeenCalled();
        expect(a.radius).toBe( MapArea.consts.DEFAULT_RADIUS);
        expect(a.minWays).toBe( MapArea.consts.DEFAULT_MIN_WAYS);
        expect(a.maxWays).toBe( MapArea.consts.DEFAULT_MAX_WAYS);
        expect(a.location).toBe(undefined);
        expect(a.logger).toBeDefined();
        expect(a.overpass).toBeDefined();
        expect(a.filter).toBeUndefined();
        expect(a.onLoaded).toBeUndefined();
        expect(a.ways).toEqual([]);
    } );

    test ( 'positive', async () => {        
        const location  = { lat:-16.7822318,lng: 145.6982588 };
        const radius = 100;

        let a = await runTest({location,radius},{setLocation:setLocationMock} );
        expect(setLocationMock).toHaveBeenCalled();
        expect(a.radius).toBe( 100);
        expect(a.location).toBeUndefined(); // is set by set Location
    } );

    test ( 'positive with onLoaded', async () => {
        
        const location  = { lat:-16.7822318,lng: 145.6982588 };
        const radius = 200;
        let onLoaded = jest.fn();

        const setLocation = jest.fn( (loc,reload,onLoadedFn) => { onLoadedFn('success', [], expected)} )
        let a = await runTest({location,radius,onLoaded},{setLocation} );

        expect(setLocation).toHaveBeenCalled();
        expect(a.radius).toBe( 200);
        expect(a.onLoaded).toBe(onLoaded);
        expect(a.location).toBeUndefined(); // is set by set Location
        expect(onLoaded).toHaveBeenCalled();
    } );


    test ( 'with filter', async () => {

        const location  = { lat:-16.7822318,lng: 145.6982588 };
        const radius = 100;
        const filter= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']

        let a = await runTest({location,radius,filter},{setLocation:setLocationMock} );

        expect(a.filter).toEqual(filter);
    } );

    test ( 'with minWays', async () => {

        const location  = { lat:-16.7822318,lng: 145.6982588 };
        
        const minWays = 1234;
        let a = await runTest({location,minWays},{setLocation:setLocationMock} );

        expect(a.minWays).toEqual(minWays);
    } );

    test ( 'with maxWays', async () => {

        const location  = { lat:-16.7822318,lng: 145.6982588 };
        
        const maxWays = 1234;
        let a = await runTest({location,maxWays},{setLocation:setLocationMock} );

        expect(a.maxWays).toEqual(maxWays);
    } );

    test ( 'no location', async () => {
        
        let radius = 100;
        let onLoaded = jest.fn();

        let init = async () => {
            let b = new MapArea({radius,onLoaded} );        
            return b
        }
        let a = await init();

        expect(onLoaded).not.toHaveBeenCalled();
        expect(a.radius).toBe(radius);
        expect(a.location).toBe(undefined);
    } );


});

describe ( 'isInitialized', () => {

    test ( 'positive', async () => {
        let a = new MapArea( );
        a.boundary= {
            northeast: { lat: 10.100, lng:0.1001},
            southwest: { lat: 10.101, lng:0.100 }
        };
        let res = a.isInitialized();
        expect(res).toBe(true);
    } );

    test ( 'negative', async () => {
        let a = new MapArea( );
        a.boundary=undefined;
        let res = a.isInitialized();
        expect(res).toBe(false);

    } );


});


describe ( 'load', () => {

    let expected = fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
    const expectedQuery = '[out:json];way[highway](-16.78313012049534,145.69732051718006,-16.781333479504664,145.69919708281992);(._;>;);out geom;';
    const defaultLocation = { lat:-16.7822318,lng: 145.6982588 };

    beforeEach(() => {
        // Clear all instances and calls to constructor and all methods:
        OverpassClient.mockClear();
      });

    const runTest = async(props)  => {
        if (props===undefined) props = {}

        let a = props.map!==undefined ? props.map : new MapArea( );
        a._buildQuery = jest.fn( ()=>expectedQuery);
        if (props.onLoaded!==undefined) a.onLoaded = props.onLoaded;
        a.location  = props.location===undefined ? defaultLocation : props.location;
        a.setData = jest.fn( (o) => {a.openmapData= o});
        a.overpass.query = jest.fn().mockImplementation(query => new Promise ( (resolve,reject) => { 
            if (props.error) {
                reject( {code:400, response:'dummy repsonse'} )
                return;
            }

            if ( query===expectedQuery) {
                resolve(expected)
            }
            else reject( {code:400, response:'dummy repsonse'} )
        } )) ;

        a.boundary = MapArea._getBoundary(a.location,100);
        await a.load();

        return a;
    }

    test ( 'positive', async () => {        
        const a = await runTest();
        expect( a.setData ).toHaveBeenCalledWith(expected,undefined)
    } );


    test ( 'error', async () => {
        
        const a = await runTest({error:true});
        expect( a.openmapData ).toBeUndefined();

    } );

    test ( 'error after success', async () => {
        
        const a = await runTest();
        await runTest({map:a, error:true});
        expect( a.openmapData ).toEqual(expected);

    } );

    test ( 'error with onLoaded set', async () => {
        const onLoaded = jest.fn()
        const a = await runTest({onLoaded,error:true});
        
        expect( a.setData ).not.toHaveBeenCalled();
        expect( onLoaded).toHaveBeenCalledWith( 'failure',[],undefined)

    } );


});

describe( 'setData', () => {

    const parseFunc= MapArea._parse;
    const defaultParsedData = { ways:["w1","w2"], nodesLookup:["n1"], waysLookup:["w1","w2"], nodes:["n1","n2"]};
    let parsedData = undefined;
    let testSet =  JSON.stringify({ someJson:{}});
    let map ;

    beforeEach( ()=> {
        if ( parsedData===undefined) parsedData = defaultParsedData
        MapArea._parse = jest.fn( (openmapData, filter) => parsedData )
    })

    afterEach( ()=> {
        MapArea._parse = parseFunc;
        parsedData = undefined;
    })

    const runTest = async(data, props)  => {
        if (props===undefined) props = {}
        map = new MapArea(props);
        if ( props.checkRoundaboutsFn) 
            map._checkRoundabouts = props.checkRoundaboutsFn 
        else  
            map._checkRoundabouts =jest.fn();
        await map.setData(data)
    }

    test( 'normal call without filter and onLoaded=undefined',async ()=> {
        // populates ways,waysLookup and nodesLookup based on parsing Result 
        // sets loaded = 'success'
        await runTest(testSet)

        expect (MapArea._parse).toHaveBeenCalledWith(testSet,undefined);
        expect (map.ways).toBe(parsedData.ways);
        expect (map.waysLookup).toBe(parsedData.waysLookup);
        expect (map.nodesLookup).toBe(parsedData.nodesLookup);
        
    });

    test( 'normal call with filter and onLoaded',async ()=> {
        // considers filter while parsing
        // populates ways,waysLookup and nodesLookup based on parsing Result 
        // sets loaded = 'success'
        // calls onLoaded 
        const filter = ["XX"];
        const onLoaded = jest.fn();
        
        await runTest(testSet,{filter,onLoaded})

        expect (MapArea._parse).toHaveBeenCalledWith(testSet,filter);
        expect (map.ways).toBe(parsedData.ways);
        expect (map.waysLookup).toBe(parsedData.waysLookup);
        expect (map.nodesLookup).toBe(parsedData.nodesLookup);
        expect (onLoaded).toHaveBeenCalled();
    });

    test( 'normal call without filter and onLoaded is defined',async ()=> {
        // considers filter while parsing
        // populates ways,waysLookup and nodesLookup based on parsing Result 
        // sets loaded = 'success'
        const onLoaded = jest.fn();
        
        await runTest(testSet,{onLoaded})

        expect (MapArea._parse).toHaveBeenCalledWith(testSet,undefined);
        expect (map.ways).toBe(parsedData.ways);
        expect (map.waysLookup).toBe(parsedData.waysLookup);
        expect (map.nodesLookup).toBe(parsedData.nodesLookup);
        expect (onLoaded).toBeCalled();
    });

    test( 'normal call with filter and onLoaded=undefined',async ()=> {
        const filter = ["XX"];
        const onLoaded = jest.fn();
        
        await runTest(testSet,{filter})

        expect (MapArea._parse).toHaveBeenCalledWith(testSet,filter);
        expect (map.ways).toBe(parsedData.ways);
        expect (map.waysLookup).toBe(parsedData.waysLookup);
        expect (map.nodesLookup).toBe(parsedData.nodesLookup);
        expect (onLoaded).not.toHaveBeenCalled();
    });

    test( 'number of ways is below limit',async ()=> {    
        
        await runTest(testSet,{minWays:200,radius:500})
        // radius is adjusted , but parsed dat remains untouched

        expect (map.radius).toBe(5000);
        expect (map.ways).toBe(parsedData.ways);
        expect (map.waysLookup).toBe(parsedData.waysLookup);
        expect (map.nodesLookup).toBe(parsedData.nodesLookup);
    });

    test( 'number of ways is above limit',async ()=> {    
        parsedData = {ways:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18],nodes:[],waysLookup:[],nodesLookup:[]}
        
        await runTest(testSet,{minWays:1,maxWays:2,radius:600})
        expect (map.radius).toBe(200);
    });

    test( 'number of ways is 0',async ()=> {        
        parsedData = {ways:[],nodes:[],waysLookup:[],nodesLookup:[]}

        await runTest(testSet,{minWays:200,radius:500})
        // radius is doubled

        expect (map.radius).toBe(1000);
    });

});

describe( 'setData - parsing Error', () => {

    let parseFunc;
    let testSet =  JSON.stringify({ someJson:{}});
    let map ;

    beforeEach( ()=> {
        parseFunc = MapArea._parse;
        MapArea._parse = jest.fn( (openmapData, filter) => undefined )
        map = new MapArea();
    })

    afterEach( ()=> {
        MapArea._parse = parseFunc;
    })

    test( ' onLoaded=undefined',()=> {
        // populates ways,waysLookup and nodesLookup based on parsing Result 
        // sets loaded = 'success'
        map.filter = undefined;
        map.onLoaded = undefined;
        map.setData(testSet)

        expect (MapArea._parse).toBeCalled();
        expect (MapArea._parse.mock.calls[0][0]).toBe(testSet);
        expect (MapArea._parse.mock.calls[0][1]).toBeUndefined();
        expect (map.openmapData).toBeUndefined();
        expect (map.loaded).toBe('failure');
    });

    test( ' onLoaded is defined',()=> {
        // populates ways,waysLookup and nodesLookup based on parsing Result 
        // sets loaded = 'success'
        map.filter = undefined;
        map.onLoaded = jest.fn();
        map.setData(testSet)

        expect (MapArea._parse).toBeCalled();
        expect (map.openmapData).toBeUndefined();
        expect (map.loaded).toBe('failure');
        expect (map.onLoaded).toBeCalled();
        expect (map.onLoaded.mock.calls[0][0]).toBe('failure');
    });

});

describe( 'collectRoundabout', () => {
    let parseFunc,map;
    const prepareData = (map,ways) => {
        map.nodesLookup=[];
        map.waysLookup=[];
        map.ways=[];
        ways.forEach( way => {
            map.ways.push(way);
            map.waysLookup[way.id]=way;
            way.path.forEach( n => {
                map.nodesLookup[n.id]=n;
            })
        })
    };
    beforeEach( ()=> {
        parseFunc = MapArea._parse;
        map = new MapArea();
        map.filter = undefined;
        map.onLoaded = undefined;
    })

    afterEach( ()=> {
        MapArea._parse = parseFunc;
    })
    
    test( '2 way  roundabout',()=> {
        let w1,w2;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w2"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n1",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
               
        prepareData(map,[w1,w2]);
        let res = map._collectRoundabout(w1);

        expect ( decodeArray(res) ).toBe('w1,w2');
    });

    test( '3 way  roundabout',()=> {
        let w1,w2,w3;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w3"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n4",ways:["w2","w3"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w3 = { id:"w3", path:[
            {id:"n4",ways:["w2","w3"]},
            {id:"n5",ways:["w3"]},
            {id:"n1",ways:["w1","w3"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
               
        prepareData(map,[w1,w2,w3]);
        let res1 = map._collectRoundabout(w1);
        let res2 = map._collectRoundabout(w2);
        let res3 = map._collectRoundabout(w3);

        expect ( decodeArray(res1) ).toBe('w1,w2,w3');
        expect ( decodeArray(res2) ).toBe('w2,w3,w1');
        expect ( decodeArray(res3) ).toBe('w3,w1,w2');
    });

    test( '4 way  roundabout',()=> {
        let w1,w2,w3,w4;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w4"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n4",ways:["w2","w3"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w3 = { id:"w3", path:[
            {id:"n4",ways:["w2","w3"]},
            {id:"n5",ways:["w3"]},
            {id:"n6",ways:["w3","w4"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w4 = { id:"w4", path:[
            {id:"n6",ways:["w3","w4"]},
            {id:"n7",ways:["w4"]},
            {id:"n1",ways:["w1","w4"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
               
        prepareData(map,[w1,w2,w3,w4]);
        let res1 = map._collectRoundabout(w1);
        let res2 = map._collectRoundabout(w2);
        let res3 = map._collectRoundabout(w3);

        expect ( decodeArray(res1) ).toBe('w1,w2,w3,w4');
        expect ( decodeArray(res2) ).toBe('w2,w3,w4,w1');
        expect ( decodeArray(res3) ).toBe('w3,w4,w1,w2');


    });

    test( 'no roundabout, not tagged',()=> {
        let w1,w2;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w2"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary'  }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n1",ways:["w1","w2"]}
        ], tags:{highway:'secondary' }};
               
        prepareData(map,[w1,w2]);
        let res = map._collectRoundabout(w1);

        expect (res).toBeUndefined();
    });


});

describe( '_generateID', () => {

    
    test( '2 way  roundabout',()=> {
               
        let id1 = MapArea._generateID(["w1","w2"]);
        let id2 = MapArea._generateID(["w2","w1"]);

        expect (id1).toBe('R:w1,w2');
        expect (id2).toBe('R:w1,w2');
    });

    test( '3 way  roundabout',()=> {
        let res1 = MapArea._generateID(["w1","w3","w2"])
        let res2 = MapArea._generateID(["w2","w1","w3"])
        let res3 = MapArea._generateID(["w3","w2","w1"])

        expect ( res1 ).toBe('R:w1,w2,w3');
        expect ( res2 ).toBe('R:w1,w2,w3');
        expect ( res3 ).toBe('R:w1,w2,w3');
    });

    test( 'exceptional: empty array',()=> {
        let id = MapArea._generateID([]);
        expect(id).toBeUndefined();
    });
    test( 'exceptional: undefined parameter',()=> {
        let id = MapArea._generateID();
        expect(id).toBeUndefined();
    });
    test( 'exceptional: array only containts 1 element',()=> {
        let id = MapArea._generateID(["w1"]);
        expect(id).toBe("w1");
    });


});

describe( '_replaceWayID', () => {
    let parseFunc,map;
    const prepareData = (map,ways) => {
        map.nodesLookup=[];
        map.waysLookup=[];
        map.ways=[];
        ways.forEach( way => {
            map.ways.push(way);
            map.waysLookup[way.id]=way;
            way.path.forEach( n => {
                map.nodesLookup[n.id]=n;
            })
        })
    };
    beforeEach( ()=> {
        parseFunc = MapArea._parse;
        map = new MapArea();
        map.filter = undefined;
        map.onLoaded = undefined;
    })

    afterEach( ()=> {
        MapArea._parse = parseFunc;
    })
    
    test( 'positive: replace single way id ',()=> {
        let w1,w2;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w2"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n1",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
               
        prepareData(map,[w1,w2]);
        
        let res = map._replaceWayID(w1,"new");

        expect ( map.waysLookup["w1"]).toBeUndefined();
        expect ( map.waysLookup["w2"]).toBeDefined();
        expect ( map.waysLookup["new"]).toBeDefined();

        expect ( res.id).toBe("new");
        expect ( res).toBe(w1);
        w1.x = "test";
        expect( map.waysLookup["new"].x).toBe("test");

        expect( decodeArray(map.nodesLookup["n1"].ways)).toBe("new,w2");
        expect( decodeArray(map.nodesLookup["n2"].ways)).toBe("new,w2");
    });

    test( 'positive: replace 2 ways of a roundabout ',()=> {
        let w1,w2;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w2"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n1",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
               
        prepareData(map,[w1,w2]);
        
        map._replaceWayID(w1,"new");
        map._replaceWayID(w2,"new", false);

        expect ( map.waysLookup["w1"]).toBeUndefined();
        expect ( map.waysLookup["w2"]).toBeUndefined();
        expect ( map.waysLookup["new"]).toBeDefined();

        expect( map.waysLookup["new"]).toBe(w1);
        
        expect( decodeArray(map.nodesLookup["n1"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n2"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n3"].ways)).toBe("new");
    });


    test( 'positive: replace 4 ways of a roundabout ',()=> {
        let w1,w2,w3,w4,w5;
        w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w4"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n8",ways:["w2","w5"]},
            {id:"n4",ways:["w2","w3"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w3 = { id:"w3", path:[
            {id:"n4",ways:["w2","w3"]},
            {id:"n5",ways:["w3"]},
            {id:"n6",ways:["w3","w4"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w4 = { id:"w4", path:[
            {id:"n6",ways:["w3","w4"]},
            {id:"n7",ways:["w4"]},
            {id:"n1",ways:["w1","w4"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        w5 = { id:"w5", path:[
            {id:"n8",ways:["w2","w5"]},
            {id:"n9",ways:["w5"]}
        ], tags:{highway:'secondary' }};

               
        prepareData(map,[w1,w2,w3,w4,w5]);
        
        map._replaceWayID(w1,"new");
        map._replaceWayID(w2,"new", false);
        map._replaceWayID(w3,"new", false);
        map._replaceWayID(w4,"new", false);

        expect ( map.waysLookup["w1"]).toBeUndefined();
        expect ( map.waysLookup["w2"]).toBeUndefined();
        expect ( map.waysLookup["w3"]).toBeUndefined();
        expect ( map.waysLookup["w4"]).toBeUndefined();
        expect ( map.waysLookup["new"]).toBeDefined();
        expect ( map.waysLookup["w5"]).toBeDefined();

        expect( map.waysLookup["new"]).toBe(w1);
        
        expect( decodeArray(map.nodesLookup["n1"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n2"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n3"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n4"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n5"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n6"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n7"].ways)).toBe("new");
        expect( decodeArray(map.nodesLookup["n8"].ways)).toBe("new,w5");
        expect( decodeArray(map.nodesLookup["n9"].ways)).toBe("w5");
    });


});
describe( '_checkRoundabouts', () => {

    let parseFunc;
    let testSet =  JSON.stringify({ someJson:{}});
    let map ;

    const prepareData = (map,ways) => {
        map.nodesLookup=[];
        map.waysLookup=[];
        map.ways=[];
        ways.forEach( way => {
            map.ways.push(way);
            map.waysLookup[way.id]=way;
            way.path.forEach( n => {
                map.nodesLookup[n.id]=n;
            })
        })
    };
    
    beforeEach( ()=> {
        parseFunc = MapArea._parse;
        map = new MapArea();
        map.filter = undefined;
        map.onLoaded = undefined;
    })

    afterEach( ()=> {
        MapArea._parse = parseFunc;
    })


    test( 'no roundabout',()=> {

        prepareData( map, [
            { id:"w1", path:[{id:"n1",ways:["w1"]}], tags:{highway:'secondary'} },
            { id:"w2", path:[{id:"n2",ways:["w2"]}], tags:{highway:'secondary'} },
        ] )
        
        map._checkRoundabouts()
        expect (map.waysLookup["w1"].tags.roundabout).toBeUndefined();
        expect (map.waysLookup["w2"].tags.roundabout).toBeUndefined();
    });


    test( 'simple roundabout',()=> {

        prepareData( map, [
            { id:"w1", path:[
                {id:"n1",ways:["w1"]},
                {id:"n2",ways:["w1","w2"]},
                {id:"n1",ways:["w1"]},
            ], tags:{highway:'secondary'} },
            { id:"w2", path:[
                {id:"n2",ways:["w1","w2"]},
                {id:"n3",ways:["w2"]}
            ], tags:{highway:'secondary'} },
        ] )
        
        map._checkRoundabouts()
        expect (map.waysLookup["w1"].tags.roundabout).toBe(true);
        expect (map.waysLookup["w2"].tags.roundabout).toBeUndefined();
    });

    test( 'complex roundabout, mixed order of nodes',()=> {

        prepareData( map, [
            { id:"w1", path:[
                {id:"n1",ways:["w1","w1.2"]},
                {id:"n2",ways:["w1","w1.1"]}
            ], tags:{highway:'secondary', junction:'roundabout'} },
            { id:"w1.2", path:[
                {id:"n5",ways:["w1.1","w1.2"]},
                {id:"n1",ways:["w1","w1.2"]},
            ], tags:{highway:'secondary', junction:'roundabout'} },
            { id:"w1.1", path:[
                {id:"n2",ways:["w1","w1.1"]},
                {id:"n3",ways:["w1.1","w2"]},
                {id:"n5",ways:["w1.1","w1.2"]},
            ], tags:{highway:'secondary', junction:'roundabout'} },
            { id:"w2", path:[
                {id:"n3",ways:["w1.1","w2"]},
                {id:"n4",ways:["w2"]}
            ], tags:{highway:'secondary'} },
        ] )
        
        map._checkRoundabouts()
        expect (map.waysLookup["w1"]).toBeUndefined();
        expect (map.waysLookup["w1.1"]).toBeUndefined();
        expect (map.waysLookup["w1.2"]).toBeUndefined();
        expect (map.waysLookup["w2"].tags.roundabout).toBeUndefined();
        expect (map.waysLookup["R:w1,w1.1,w1.2"]).toBeDefined();

        let wr = map.waysLookup["R:w1,w1.1,w1.2"];
        expect(wr.tags.roundabout).toBe(true);
        expect( decodePath(wr.path) ).toBe('n1,n2,n3,n5,n1');

        let n1 = map.nodesLookup["n2"];
        expect(n1.ways.length).toBe(1);
        expect(n1.ways[0]).toBe("R:w1,w1.1,w1.2");

        let n2 = map.nodesLookup["n2"];
        expect(n2.ways.length).toBe(1);
        expect(n2.ways[0]).toBe("R:w1,w1.1,w1.2");

        let n3 = map.nodesLookup["n3"];
        expect(n3.ways.length).toBe(2);
        expect(n3.ways[0]).toBe("R:w1,w1.1,w1.2");
        expect(n3.ways[1]).toBe("w2");

        let n4 = map.nodesLookup["n4"];
        expect(n4.ways.length).toBe(1);
        expect(n4.ways[0]).toBe("w2");

        let n5 = map.nodesLookup["n5"];
        expect(n5.ways.length).toBe(1);
        expect(n5.ways[0]).toBe("R:w1,w1.1,w1.2");

    });



});

describe ( 'setLocation', () => {

    let boundaryFunc;
    let map ;
    let boundaryData = { northeast:{ lat:1,lng:1}, southwest:{lat:2,lng:2}}

    beforeEach( ()=> {
        boundaryFunc = MapArea._getBoundary;
        MapArea._getBoundary = jest.fn( (location,radius) => boundaryData)
        map = new MapArea();
        map.load= jest.fn();
    })

    afterEach( ()=> {
        MapArea._getBoundary = boundaryFunc ;
        ;
    })


    test ( 'positive reload=true, onLoaded is specified',  () => {
        const onLoaded = jest.fn();
        const testLocation = {id:"n1",lat:2,lng:2};

        map.setLocation( testLocation,true, onLoaded);
        expect(map.location).toBe(testLocation);
        expect(MapArea._getBoundary).toBeCalled();
        expect(map.load).toBeCalled();
 
    } );
    test ( 'positive reload=false, onLoaded is specified',  () => {
        const onLoaded = jest.fn();
        const testLocation = {id:"n1",lat:2,lng:2};

        map.setLocation( testLocation,false, onLoaded);
        expect(map.location).toBe(testLocation);
        expect(MapArea._getBoundary).not.toBeCalled();
        expect(map.load).not.toBeCalled();
        expect(onLoaded).toBeCalled();
        expect(onLoaded.mock.calls[0][0]).toBe('success');
 
    } );
    test ( 'positive reload=true, onLoaded is not specified',  () => {
        const testLocation = {id:"n1",lat:2,lng:2};

        map.setLocation( testLocation,true, undefined);
        expect(map.location).toBe(testLocation);
        expect(MapArea._getBoundary).toBeCalled();
        expect(map.load).toBeCalled();
 
 
    } );
    test ( 'positive reload=false, onLoaded is not specified', () => {
        const onLoaded = jest.fn();
        const testLocation = {id:"n1",lat:2,lng:2};

        map.onLoaded = onLoaded;
        map.setLocation( testLocation,false, undefined);
        expect(map.location).toBe(testLocation);
        expect(MapArea._getBoundary).not.toBeCalled();
        expect(map.load).not.toBeCalled();
        expect(onLoaded).not.toBeCalled();
 
    } );

    test ( 'negative: location is undefined onLoaded is not specified',  () => {
        map.setLocation( undefined,true);
        expect(map.location).toBeUndefined();
        expect(MapArea._getBoundary).not.toBeCalled();
        expect(map.load).not.toBeCalled();
    } );

    test ( 'negative: location is undefined onLoaded is specified',  () => {
        const onLoaded = jest.fn();

        map.setLocation( undefined,true, onLoaded);
        expect(map.location).toBeUndefined();
        expect(MapArea._getBoundary).not.toBeCalled();
        expect(map.load).not.toBeCalled();
        expect(onLoaded).toBeCalled();
        expect(onLoaded.mock.calls[0][0]).toBe('failure');
    
 
    } );

    test ( 'negative: radius is undefined ',  () => {
        // TODO
    } );


})

describe ( '_buildQuery', () => {
    test ( 'positive test', () => {
        let a = new MapArea();
        a.boundary = {
            northeast: { lat: 10.100, lng:0.1001},
            southwest: { lat: 10.101, lng:0.100 }
        }
        let str = a._buildQuery('way[highway](__boundary__);(._;>;);out geom;');
        expect ( str ).toBe('way[highway](10.101,0.1,10.1,0.1001);(._;>;);out geom;')

    } );

    test ( 'undefined', () => {
        let a = new MapArea();
        let str = a._buildQuery();
        expect ( str ).toBeUndefined();

    } );


});

describe ( 'getNearestPath - London', () => {
    let testData = fs.readFileSync('./__testdata__/overpass-london.json','UTF-8');
   
    let area = new MapArea();
    area.setData(testData);

    test ( 'Default Point', () => {
        let location  = {lat:51.50161319206912, lng:-0.17620057086401175};
        let res = area.getNearestPath( location);
        
        expect ( res.path ).toBeDefined();
        expect ( res.way.id).toBe('372971026')
        expect ( res.way.name).toBe('Kensington Gore');

    } )



    test ( 'Exhibition Road', () => {
        let location  = {lat: 51.50124960223127, lng: -0.174558162689209};
        let res = area.getNearestPath( location);

        
        expect ( res.path ).toBeDefined();
        expect ( res.way.name).toBe('Exhibition Road');
        //console.log(res);

    } )

})

describe ( 'getNearestPath', () => {
    let testData =  fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
    let testWays = MapArea._parse(testData).ways;
    let area = new MapArea();
    area.setData(testData);

    test ( 'on 1st point in path #1', () => {

        let res = area.getNearestPath( testWays[0].path[0]);
        expect ( res.path ).toBeDefined();
        expect ( res.distance ).toBe(0);
        expect ( res.path[0].lat ).toBe(testWays[0].path[0].lat);
        expect ( res.path[0].lng ).toBe(testWays[0].path[0].lng);


    } );
    test ( 'on 1st point in path #2', () => {

        let res = area.getNearestPath(testWays[1].path[0] );
        expect ( res.path ).toBeDefined();
        expect ( res.distance ).toBe(0);
        expect ( res.path[0].lat ).toBe(testWays[1].path[0].lat);
        expect ( res.path[0].lng ).toBe(testWays[1].path[0].lng);


    } );
    test ( 'rd point on 1st path', () => {
        let location = { lat: -16.7824429, lng: 145.6983982 };
        let res = MapArea._getNearestPath(location,testWays );
        expect ( res.path ).toBeDefined();
        expect ( res.distance ).toBe(0);
        expect ( res.path[0].lat ).toBe(testWays[0].path[0].lat);
        expect ( res.path[0].lng ).toBe(testWays[0].path[0].lng);
        
    } );

    test ( 'last point in path', () => {
    } );

    test ( 'undefined point', () => {
        let res = area.getNearestPath();
        expect ( res ).toBeUndefined();
    } );

    test ( 'two ways with same distance -> delivers first match', () => {
        let fn = MapArea._distanceToPath;
        MapArea._distanceToPath = jest.fn ( (point,w) => 1);

        let location = { lat: -16.7824429, lng: 145.6983982 };
        let ways = [
            { id:"w1", path: [ {id:"1"},{id:"2"}] },
            { id:"w2", path: [ {id:"3"},{id:"4"}] },
        ]
        let res;
        try {
            area.ways = ways;
            res = area.getNearestPath(location);
        }
        catch(e) {}
        MapArea._distanceToPath = fn;

        expect(res.way.id).toBe("w1");
        expect(res.distance).toBe(1);

    });

    test ( 'error: _distanceToPath returns undefined', () => {
        let fn = MapArea._distanceToPath;
        let i = 0;
        MapArea._distanceToPath = jest.fn ( (point,w) => { if (i++!==1) return 10-i });

        let location = { lat: -16.7824429, lng: 145.6983982 };
        let ways = [
            { id:"w1", path: [ {id:"1"},{id:"2"}] },
            { id:"w2", path: [ {id:"3"},{id:"4"}] },
            { id:"w3", path: [ {id:"5"},{id:"6"}] },
        ]
        let res;
        try {
            area.ways = ways;
            res = area.getNearestPath(location);
        }
        catch(e) {}
        MapArea._distanceToPath = fn;

        expect(res.way.id).toBe("w3");
        expect(res.distance).toBe(7);

    });

});

describe ( '_isWithinRange', () => {

    test ( 'less than 5meter => true', () => {
        let res = MapArea._isWithinRange(4.99) 
        expect ( res).toBe( true );
    } );
    test ( 'exactly 5meter => false', () => {
        let res = MapArea._isWithinRange(5.0) 
        expect ( res).toBe( false );
    } );
    test ( 'more than 5meter => false', () => {
        let res = MapArea._isWithinRange(5.01) 
        expect ( res ).toBe( false);
    } );
    test ( 'negative: less than 5meter => false', () => {
        let res = MapArea._isWithinRange(-4.99) 
        expect ( res ).toBe( true);
    } );
    test ( 'negative: more than 5meter => false', () => {
        let res = MapArea._isWithinRange(-499) 
        expect ( res ).toBe( false);
    } );
    test ( 'undefined', () => {
        let res = MapArea._isWithinRange() 
        expect ( res).toBe( false );
    } );

})

describe ( '_isOnPath', () => {
    let testData = fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
    let testWays = MapArea._parse(testData).ways;

    test ( '1st point in path', () => {
        let res = MapArea._isOnPath({lat: -16.7820535, lng:145.6982433},testWays[0]);
        expect ( res ).toBe(true);
    } );
    test ( 'close to 1st point in path', () => {
        let res = MapArea._isOnPath({lat: -16.78205351, lng:145.6982433},testWays[0]);
        expect ( res ).toBe(true);
    } );
    test ( 'last point in path', () => {
        let res = MapArea._isOnPath({lat: -16.7901496, lng:145.7021109},testWays[0]);
        expect ( res ).toBe(true);
    } );
    test ( 'point mentioned in path, but between two points on path', () => {
        let res = MapArea._isOnPath({lat: -16.784788, lng: 145.699349},testWays[0]);
        expect ( res ).toBe(true);
    } );
    test ( 'point not mentioned in path, nearby', () => {
        let res = MapArea._isOnPath({lat: -16.785602, lng:145.698518},testWays[0]);
        expect ( res ).toBe(false);
    } );
    test ( 'point not mentioned in path,far away', () => {
        let res = MapArea._isOnPath({lat: 1, lng:1},testWays[0]);
        expect ( res ).toBe(false);
    } );

    test( 'London: Kensington Gore - negative',() => {

        // point is on Exhibition Road -- roughly 200m away from Kensington Gore
        let kensingtonGore = { path: [
            { lat: 51.5009417, lng: -0.1766302 },
            { lat: 51.5009124, lng: -0.1766902 },
            { lat: 51.5008724, lng: -0.1767127 },
            { lat: 51.5008565, lng: -0.1767216 },
            { lat: 51.5007505, lng: -0.1768211 },
            { lat: 51.5006646, lng: -0.1769241 },
            { lat: 51.5006962, lng: -0.1766185 },
            { lat: 51.5007115, lng: -0.1764709 },
            { lat: 51.5007399, lng: -0.1763730 }
          ]
        };
        let res = MapArea._isOnPath({lat: 51.50124960223127, lng: -0.174558162689209}, kensingtonGore);
        expect ( res ).toBe(false);
    } )


    test ( 'undefined point', () => {
        let res = MapArea._isOnPath(undefined,{});
        expect ( res ).toBe(false);
    } );
    test ( 'undefined path', () => {
        let res = MapArea._isOnPath({lat: 10.100, lng:0.1001});
        expect ( res ).toBe(false);
    } );


});

describe ( '_isBetween', () => {

    test ( 'point inbetween', () => {
        let p1 = {lat:-16.784788, lng:145.699349 };
        let p2 = {lat:-16.7852118, lng:145.6995816 };

        let res = MapArea._isBetween({lat:-16.784891,lng: 145.699397},p1,p2) 
        expect ( res.between ).toBe( true );
    } );

    test ( 'point before', () => {
        let p1 = {lat:-16.784788, lng:145.699349 };
        let p2 = {lat:-16.7852118, lng:145.6995816 };

        let res = MapArea._isBetween({lat:-16.784503,lng: 145.699180},p1,p2) 
        expect ( res.between ).toBe( false );
    } );

    test ( 'point after', () => {
        let p1 = {lat:-16.784788, lng:145.699349 };
        let p2 = {lat:-16.7852118, lng:145.6995816 };

        let res = MapArea._isBetween({lat:-16.785314, lng:145.699639},p1,p2) 
        expect ( res.between ).toBe( false );
    } );

    test ( 'point parallel', () => {

        let p1 = {lat:-16.784788, lng:145.699349 };
        let p2 = {lat:-16.7852118, lng:145.6995816 };

        let res = MapArea._isBetween({lat:-16.785172, lng:145.699311},p1,p2) 
        expect ( res.between ).toBe( false );
    } );

    test ( 'missing parameters', () => {
        let res = MapArea._isBetween() 
        expect ( res ).toBe( undefined );
    } );

});

describe ( '_distanceToPath', () => {
    let testData = fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
    let testWays = MapArea._parse(testData).ways;

    function getPointBetween(p1,p2,offset) {
        
        let b = initialBearingTo(p1,p2);
        return destinationPoint(p1,offset,b);
        /*
        let distanceBetweenP1P2 = calculateDistance(p1.lat,p1.lng,p2.lat,p2.lng) ;
        if (offset>distanceBetweenP1P2)
            return p2;
    
        let m = offset/distanceBetweenP1P2;
        let lat= p1.lat + (p2.lat-p1.lat)*m;
        let lng = p1.lng + (p2.lng-p1.lng)*m;
        return {lat,lng};
        */
    }

    let way = testWays[0];
    let p0 = way.path[0];
    let p1 = way.path[1];
    let pn1 = way.path[way.path.length-2];
    let pn = way.path[way.path.length-1];

    test ( '1st point in path', () => {
        let res = MapArea._distanceToPath({lat: -16.7820535, lng:145.6982433},testWays[0]);
        expect ( res ).toBe(0);
    } );
    test ( 'close to 1st point in path', () => {
        let res = MapArea._distanceToPath({lat: -16.78205351, lng:145.6982433},testWays[0]);
        expect ( res ).toBeLessThan( 5 )
    } );
    // distance betweenn p0 and p1 is 23m 
    test ( '10m away from 1st point', () => {
        let p = getPointBetween(p0,p1,10);
        let res = MapArea._distanceToPath(p,testWays[0]);
        expect ( res ).toBeLessThan( 5 )
    } );
    test ( '10m before 2nd point', () => {
        let p = getPointBetween(p0,p1,13);
        let res = MapArea._distanceToPath(p,testWays[0]);
        expect ( res ).toBeLessThan( 5 )
    } );
    // distance between p(n-1) and p(n) is 18.8m
    test ( '10m before last point', () => {
        let p = getPointBetween(pn1,pn,11.8);
        let res = MapArea._distanceToPath(p,testWays[0]);
        expect ( res ).toBeLessThan( 5 )
    } );
    test ( 'last point in path', () => {
        let res = MapArea._distanceToPath({lat: -16.7901496, lng:145.7021109},testWays[0]);
        expect ( res ).toBe(0);
    } );
    test ( 'point mentioned in path, but between two points on path', () => {
        let res = MapArea._distanceToPath({lat: -16.784788, lng: 145.699349},testWays[0]);
        expect ( res ).toBeLessThan( 5 );
    } );
    test ( 'point not mentioned in path, nearby', () => {
        let res = MapArea._distanceToPath({lat: -16.785602, lng:145.698518},testWays[0]);
        expect ( res ).toBeGreaterThan( 5 )
    } );
    test ( 'point not mentioned in path,far away', () => {
        let res = MapArea._distanceToPath({lat: 1, lng:1},testWays[0]);
        expect ( res ).toBeGreaterThan( 10000 )
    } );


    test ( 'undefined point', () => {
        let res = MapArea._distanceToPath(undefined,{});
        expect ( res ).toBeUndefined();
    } );
    test ( 'undefined path', () => {
        let res = MapArea._distanceToPath({lat: 10.100, lng:0.1001});
        expect ( res ).toBeUndefined();
    } );


});

describe ( 'addWay',()=> {

    let ways, waysLookup;

    beforeEach( ()=> {
        ways = [];
        waysLookup= [];
    })

    test( 'single',()=> {
        let w = { id:"w1"}
        MapArea.addWay(w,ways,waysLookup);
        expect(ways.length).toBe(1);
        expect(waysLookup["w1"]).toBe(w);
    })

    test( 'multiple different',()=> {
        let w1 = { id:"w1",path:[ {id:"n1"}, {id:"n2"} ]}
        let w2 = { id:"w2",path:[ {id:"n3"}, {id:"n3"} ]}
        MapArea.addWay(w1,ways,waysLookup);
        MapArea.addWay(w2,ways,waysLookup);
        expect(ways.length).toBe(2);
        expect(waysLookup["w1"]).toBe(w1);
        expect(waysLookup["w2"]).toBe(w2);
        
    })

    test( 'multiple with duplicates',()=> {
        let w1 = { id:"w1",path:[ {id:"n1"}, {id:"n2"} ]}
        let w2 = { id:"w1",path:[ {id:"n3"}, {id:"n3"} ]}
        MapArea.addWay(w1,ways,waysLookup);
        MapArea.addWay(w2,ways,waysLookup);
        expect(ways.length).toBe(1);
        expect(waysLookup["w1"]).toBe(w2);
        
    })

})

describe ( '_parse', () => {
    let testData =  fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8') 

    test ( 'positive test - data is string - ways', () => {
        let {ways} = MapArea._parse(testData);
        expect(ways.length).toBe(4);
        expect(ways[0].id).toBe('4815077');
        expect(ways[0].type).toBe('unclassified');expect(ways[0].name).toBe('Vasey Esplanade')
        expect(ways[0].path[0].lat).toBe(-16.7820535)
        expect(ways[0].path[0].lng).toBe(145.6982433)
        expect(ways[0].path[0].ways.find( e=>(e==='4815077'))).toBeDefined();
        expect(ways[0].path[0].ways.find( e=>(e==='183973236'))).toBeUndefined(); 
        
        expect(ways[1].id).toBe('183973236');
        expect(ways[1].type).toBe('path');expect(ways[1].name).toBeUndefined();

        expect(ways[2].id).toBe('183973238');
        expect(ways[2].type).toBe('service');expect(ways[2].name).toBeUndefined();
        
        expect(ways[3].id).toBe('184561984');
        expect(ways[3].type).toBe('footway');expect(ways[3].name).toBeUndefined();

    } );

    test ( 'positive test - data is object - ways', () => {
        let {ways} = MapArea._parse(JSON.parse(testData));
        expect(ways.length).toBe(4);
        expect(ways[0].id).toBe('4815077');
        expect(ways[0].type).toBe('unclassified');expect(ways[0].name).toBe('Vasey Esplanade')
        expect(ways[0].path[0].lat).toBe(-16.7820535)
        expect(ways[0].path[0].lng).toBe(145.6982433)
        expect(ways[0].path[0].ways.find( e=>(e==='4815077'))).toBeDefined();
        expect(ways[0].path[0].ways.find( e=>(e==='183973236'))).toBeUndefined(); 
        
        expect(ways[1].id).toBe('183973236');
        expect(ways[1].type).toBe('path');expect(ways[1].name).toBeUndefined();

        expect(ways[2].id).toBe('183973238');
        expect(ways[2].type).toBe('service');expect(ways[2].name).toBeUndefined();
        
        expect(ways[3].id).toBe('184561984');
        expect(ways[3].type).toBe('footway');expect(ways[3].name).toBeUndefined();

    } );


    test ( 'positive test - waysLookup', () => {
        let res = MapArea._parse(testData);
        expect(res.waysLookup['4815077'].name).toBe('Vasey Esplanade')

    } );

    test ( 'positive test - ways', () => {
        let {ways} = MapArea._parse(testData);
        expect(ways.length).toBe(4);
        expect(ways[0].id).toBe('4815077');
        expect(ways[0].type).toBe('unclassified');expect(ways[0].name).toBe('Vasey Esplanade')
        expect(ways[0].path[0].lat).toBe(-16.7820535)
        expect(ways[0].path[0].lng).toBe(145.6982433)
        expect(ways[1].type).toBe('path');expect(ways[1].name).toBeUndefined();
        expect(ways[2].type).toBe('service');expect(ways[2].name).toBeUndefined();
        expect(ways[3].type).toBe('footway');expect(ways[3].name).toBeUndefined();

    } );


    test ( 'missing index in way => providing internal index', () => {

        let data = JSON.parse(fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8'));
        // remove id from 2nd element
        let idx=0;
        data.elements.forEach( element => {
            if (element.type==='way' ) {
                if (idx===2) delete element.id;
                idx++;
            }
        })

        let res = MapArea._parse(JSON.stringify(data));
        expect(res.ways.length).toBe(4);
        expect(res.ways[2].type).toBe('service');
        expect(res.ways[2].id).toBe('_INT_2');
        expect(res.waysLookup['_INT_2'].type).toBe('service');

    } );

    test ( 'missing tags in way => filtering out way', () => {

        let data = JSON.parse(fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8'));
        // remove tags from 2nd element
        let idx=0;
        data.elements.forEach( element => {
            if (element.type==='way' ) {
                if (idx===2) delete element.tags;
                idx++;
            }
        })

        let res = MapArea._parse(JSON.stringify(data));
        expect(res.ways.length).toBe(3);
        expect(res.ways[0].tags).toBeDefined();
        expect(res.ways[0].type).toBeDefined();
        expect(res.ways[1].tags).toBeDefined();
        expect(res.ways[1].type).toBeDefined();
        expect(res.ways[2].tags).toBeDefined();
        expect(res.ways[2].type).toBeDefined();

    } );


    test ( 'no geometry data', () => {

        let data = JSON.parse(fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8'));
        // remove geometry info
        data.elements.forEach( element => {
            if (element.type==='way' && element.geometry!==undefined)
                delete element.geometry;
        })

        let {ways} = MapArea._parse(JSON.stringify(data));
        expect(ways.length).toBe(4);
        expect(ways[0].type).toBe('unclassified');expect(ways[0].name).toBe('Vasey Esplanade')
        expect(ways[0].path[0].lat).toBe(-16.7820535)
        expect(ways[0].path[0].lng).toBe(145.6982433)
        expect(ways[1].type).toBe('path');expect(ways[1].name).toBeUndefined();
        expect(ways[2].type).toBe('service');expect(ways[2].name).toBeUndefined();
        expect(ways[3].type).toBe('footway');expect(ways[3].name).toBeUndefined();

    } );

    test ( 'undefined', () => {
        let ways = MapArea._parse(undefined);
        expect(ways).toBeUndefined();
    } );

    test ( 'invalid object', () => {
        let ways = MapArea._parse("xxx = undefined");
        expect(ways).toBeUndefined();
    } );

    test ( 'no elements', () => {
        let ways = MapArea._parse({});
        expect(ways).toBeUndefined();
    } );


});

describe ( 'splitAtFirstBranch', () => {


    test ( 'positive test - branch finishing at crossing', () => {
        
        let testSet =  fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8')
        let map = new MapArea();
        map.setData(testSet)
        let VaseyEsplanade = map.waysLookup['4815077'];
        let res = map.splitAtFirstBranch(VaseyEsplanade);

        expect(res.way.id).toBe('4815077');
        expect(res.way.path.length).toBe(3);
        expect(res.branches.length).toBe(2);
        expect(res.branches[0].id).toBe('4815077')
        expect(res.branches[1].id).toBe('183973238')
        expect(res.branches[0].path.length).toBe(9)
        expect(res.branches[1].path.length).toBe(6)
        expect(res.branches[1].path[0].id).toBe('1944102704')
        expect(res.branches[1].path[5].id).toBe('1944102701')
    } );

    test ( 'positive test - branch  starting at crossing', () => {
        
        let testSet =   fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
        let map = new MapArea();
        map.setData(testSet)
        let VaseyEsplanade = map.waysLookup['4815077'];
        VaseyEsplanade.path.reverse();
        for (var i=0;i<17;i++) VaseyEsplanade.path.shift(); 
        
        let res = map.splitAtFirstBranch(VaseyEsplanade);

        expect(res.way.id).toBe('4815077');
        expect(res.way.path.length).toBe(7);
        expect(res.branches.length).toBe(2);
        expect(res.branches[0].id).toBe('4815077')
        expect(res.branches[1].id).toBe('183973238')
        expect(res.branches[0].path.length).toBe(4)        
        expect(res.branches[1].path.length).toBe(6)
        expect(res.branches[0].path[0].id).toBe('1944102701')
        expect(res.branches[0].path[3].id).toBe('1941090209')
        expect(res.branches[1].path[0].id).toBe('1944102701')
        expect(res.branches[1].path[5].id).toBe('1944102704')
    } );

    test ( 'positive test - branch crossing in the middle', () => {
        
        let testSet =  fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8');
        let map = new MapArea();
        map.setData(testSet)
        let VaseyEsplanade = map.waysLookup['4815077'];
        VaseyEsplanade.path.reverse();
        for (var i=0;i<11;i++) VaseyEsplanade.path.shift();
        let res = map.splitAtFirstBranch(VaseyEsplanade);

        expect(res.way.id).toBe('4815077');
        expect(res.way.path.length).toBe(6);
        expect(res.branches.length).toBe(3);
        expect(res.branches[0].id).toBe('4815077')
        expect(res.branches[1].id).toBe('184561984')
        expect(res.branches[2].id).toBe('184561984')
        expect(res.branches[0].path.length).toBe(8)        
        expect(res.branches[1].path.length).toBe(5)
        expect(res.branches[1].path[0].id).toBe('1941090215')
        expect(res.branches[1].path[4].id).toBe('1950581761')
        expect(res.branches[2].path.length).toBe(6)
        expect(res.branches[2].path[0].id).toBe('1941090215')
        expect(res.branches[2].path[5].id).toBe('1950581698')
    } );

    test ( 'negative: way does not have branches', () => {
        let way = { id:'test', path: [
            {id:"1",lat:1,lng:0,ways:['test']},
            {id:"2",lat:2,lng:0,ways:['test']},
            {id:"3",lat:3,lng:0,ways:['test']}
        ]}
        let map = new MapArea();
        let res = map.splitAtFirstBranch(way);
        
        expect(res.way.id).toBe('test');
        expect(res.way.path.length).toBe(3);
        expect(res.branches.length).toBe(0);
        
    } );

 
    test ( 'negative: missing arguments', () => {
        let map = new MapArea();
        let res = map.splitAtFirstBranch();
        expect(res).toBeUndefined();
        
    } );

});




describe ( '_boundaryToString', () => {
      
    test ( 'positive test', () => {
        let boundary = {
            northeast: { lat: 10.100, lng:0.1001},
            southwest: { lat: 10.101, lng:0.100 }
        }
        let str = MapArea._boundaryToString(boundary);
        expect ( str ).toBe('10.101,0.1,10.1,0.1001')

    } );


    test ( 'undefined -> returns "undefined"', () => {
        let str = MapArea._boundaryToString(undefined);
        expect ( str ).toBe('undefined')

    } );

    test ( 'empty boundary -> returns "undefined"', () => {
        let str = MapArea._boundaryToString({});
        expect ( str ).toBe('undefined')

    } );

    test ( 'missing ne -> presets ne with value of se', () => {
        let boundary = {           
            southwest: { lat: 10.101, lng:0.100 }
        }
        let str = MapArea._boundaryToString(boundary);
        expect ( str ).toBe('10.101,0.1,10.101,0.1')

    } );

    test ( 'missing ne lat-> sets error', () => {
        let boundary = {           
            northeast: { lng:0.1001},
            southwest: { lat: 10.101, lng:0.100 }
        }
        let str = MapArea._boundaryToString(boundary);
        expect ( str ).toBe('error: northeast incorrect')

    } );

    test ( 'missing sw lat-> sets error', () => {
        let boundary = {           
            northeast: { lat: 10.100, lng:0.1001},
            southwest: {   lng:0.100 }
        }
        let str = MapArea._boundaryToString(boundary);
        expect ( str ).toBe('error: southwest incorrect')

    } );


    test ( 'missing sw -> presets sw with value of ne', () => {
        let boundary = {
            northeast: { lat: 10.100, lng:0.1001},
        }
        let str = MapArea._boundaryToString(boundary);
        expect ( str ).toBe('10.1,0.1001,10.1,0.1001')

    } );


} )


describe ('findAdditional', () => {
    test ( 'positive test', () => {

        let a1 = ["183973238"]
        let a2 = ["4815077","183973238"]

        let res =  findAdditional(a1,a2,'4815077',(id1,id2)=>(id1===id2))
        expect(res).toBeUndefined();

    } );

} )

describe ( 'checkOptionsOnCurrentWay', () => {

    function cw(way, roundabout) {
        let w=JSON.parse(JSON.stringify(way)); 
        delete w[0];
        return {w,roundabout}
    }

    let map
    beforeEach( ()=> {
        map = new MapArea();
    }) 

    test( 'positive - no roundabout' ,()=> {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"},{id:"n3"}, {id:"n4"} ]};
        let wayRemaining = { id:"w1-clone", path: [  {id:"n4"},{id:"n5"}, {id:"n6"} ]};
        let split = { way:{ id:"w2", path: [ {id:"n1"}, {id:"n2"}]}}
        let options = [];

        map.copyWay = jest.fn( (way) => cw(wayRemaining,false)  ) 
        map.splitAtFirstBranch = jest.fn( (way) => split); 

        map.checkOptionsOnCurrentWay({id:"n3"},way,options);

        expect(map.splitAtFirstBranch).toBeCalled();
        expect(map.splitAtFirstBranch.mock.calls[0][0].id).toBe("w1-clone");
        expect(options.length).toBe(1);
        expect(options[0]).toBe(split.way);
    })

    test( 'positive - roundabout' ,()=> {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"},{id:"n3"}, {id:"n4"},{id:"n1"} ]};
        
        let branches = [ {id:"w1", path: [ {id:"n3"}, {id:"n4"}]}, { id:"w1", path: [ {id:"n3"}, {id:"n2"}]} ]
        let options = [];

        map.copyWay = jest.fn( (way) => cw(way,true)  ) 
        map.splitWayAtPoint = jest.fn( (w,location,way) => branches); 

        map.checkOptionsOnCurrentWay({id:"n3"},way,options);

        expect(map.splitWayAtPoint).toBeCalled();
        expect(map.splitWayAtPoint.mock.calls[0][0].id).toBe("w1");
        expect(map.splitWayAtPoint.mock.calls[0][1].id).toBe("n3");
    })

    test( 'excpetional - no points left on road' ,()=> {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"},{id:"n3"}, {id:"n4"} ]};
        let wayRemaining = { id:"w1-clone", path: [  {id:"n4"} ]};
        let split = { way:{ id:"w2", path: [ {id:"n1"}, {id:"n2"}]}}
        let options = [];

        map.copyWay = jest.fn( (way) => cw(wayRemaining,false)  ) 
        map.splitAtFirstBranch = jest.fn( (way) => split); 

        map.checkOptionsOnCurrentWay({id:"n3"},way,options);

        expect(map.splitAtFirstBranch).not.toBeCalled();
        expect(options.length).toBe(0);
    })

})

describe ( 'getNextOptions ', () => {
    let map;
    let boundaryFunc;
    let boundaryData = { northeast:{ lat:1,lng:1}, southwest:{lat:2,lng:2}}
    let setLocationSpy;
    let expected = [];

    beforeEach( ()=> {
        boundaryFunc = MapArea._getBoundary;
        MapArea._getBoundary = jest.fn( (location,radius) => boundaryData)
        map = new MapArea({minWays:1});
        map._getNextOptions = jest.fn( (loc, way,way1,status) => expected);
        setLocationSpy = jest.spyOn(map, 'setLocation');
        map.load = jest.fn( (cb) => { cb('success')} )
    })

    afterEach( ()=> {
        MapArea._getBoundary = boundaryFunc;  
    })

    test ( 'positive test - no exclusion, no reload', async () => {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"}]};
        let options = await map.getNextOptions( way);

        expect(setLocationSpy).toBeCalled();
        expect(map.setLocation.mock.calls[0][0].id).toBe("n2");
        expect(map.setLocation.mock.calls[0][1]).toBe(false);

        expect(map._getNextOptions).toBeCalled();
        expect(map._getNextOptions.mock.calls[0][0].id).toBe("n2");
        expect(map._getNextOptions.mock.calls[0][1].id).toBe("w1");
        expect(map._getNextOptions.mock.calls[0][2]).toBeUndefined();
        expect(options).toBe(expected);
    });

    test ( 'positive test - no exclusion, with reload', async () => {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"}]};
        let options = await map.getNextOptions( way,undefined,true);

        expect(setLocationSpy).toBeCalled();
        expect(map.setLocation.mock.calls[0][0].id).toBe("n2");
        expect(map.setLocation.mock.calls[0][1]).toBe(true);

        expect(map._getNextOptions).toBeCalled();
        expect(map._getNextOptions.mock.calls[0][0].id).toBe("n2");
        expect(map._getNextOptions.mock.calls[0][1].id).toBe("w1");
        expect(map._getNextOptions.mock.calls[0][2]).toBeUndefined();

        expect(options).toBe(expected);
    });

    test ( 'positive test - with exclusion, with reload', async () => {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"}]};
        let excl =  { id:"w2"};
        let options = await map.getNextOptions( way, excl,true);

        expect(setLocationSpy).toBeCalled();
        expect(map.setLocation.mock.calls[0][0].id).toBe("n2");
        expect(map.setLocation.mock.calls[0][1]).toBe(true);

        expect(map._getNextOptions).toBeCalled();
        expect(map._getNextOptions.mock.calls[0][0].id).toBe("n2");
        expect(map._getNextOptions.mock.calls[0][1].id).toBe("w1");
        expect(map._getNextOptions.mock.calls[0][2]).toBe(excl);

        expect(options).toBe(expected);
    });

    test ( 'negative test - missing argument: way', async () => {
        let exception;
        try {
            await map.getNextOptions( );
        }
        catch(e) { exception = e}
        expect(exception.message).toBe('invalid arguments');
    });
    test ( 'negative test - way : missing path', async () => {
        let exception;
        try {
            await map.getNextOptions( {id:"w1"});
        }
        catch(e) { exception = e}
        expect(exception.message).toBe('invalid arguments');
    });
    test ( 'negative test - way : missing id', async () => {
        let exception;
        try {
            await map.getNextOptions( {});
        }
        catch(e) { exception = e}
        expect(exception.message).toBe('invalid arguments');
    });


    test ( 'negative test - way : invalid path', async () => {
        let exception;
        try {
            await map.getNextOptions( {id:"w1",path:[]});
        }
        catch(e) { exception = e}
        expect(exception.message).toBe('invalid arguments');
    });

    test ( 'exceptional case - way : missing id in last element of path', async () => {
        await map.getNextOptions( {id:"w1",path:[ {id:"nx"},{}]});
        expect(setLocationSpy).toBeCalled();
        expect(map.setLocation.mock.calls[0][0].id).toBe("nx");
    });

    test ( 'exceptional case - way : missing id in last element of path, but length==1', async () => {
        let options = await map.getNextOptions( {id:"w1",path:[ {}]});
        expect(setLocationSpy).not.toBeCalled();
        expect(options.length).toBe(0);

    });

    test ( 'negative test - set Location fails', async () => {
        let way = { id:"w1", path: [ {id:"n1"}, {id:"n2"}]};
        let exception;
        map.setLocation = jest.fn(  (location, reload,cb) => {cb('failure')} )
        try {
            await map.getNextOptions(way);
        }
        catch(e) { exception = e}
        expect(exception.message).toBe('could not load data');
    });

});

describe ( 'getNextOptions - component test', () => {


    test ( 'positive test ', async () => {
        let testData =  fs.readFileSync('./__testdata__/GetNextOptions-map.json','UTF-8');
        const WAY_FILTER= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']
        let map = new MapArea();
        map.filter = WAY_FILTER; 
        map.setData(testData);
        map.radius = 500;

        let Hehn = map.waysLookup['37590936'];
        Hehn.path.reverse();
        
        let res = await  map.getNextOptions(Hehn);

        expect(res.length).toBe(2);
        //expect(res[1].id).toBe('19800801')
        expect(res[0].id).toBe('19800215')      // de-prioritized,because one-way (against direction)
        expect(res[0].path.length).toBe(2);      // [180878199 , 206337406]

        expect(res[1].id).toBe('30783368')
        expect(res[1].path.length).toBe(3);      // [180878199 , 4675030719, 180878193 ]
 
    } );

    test ( 'negative: missing location id ', async () => {
        let testData =  fs.readFileSync('./__testdata__/GetNextOptions-map.json','UTF-8');
        const WAY_FILTER= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']
        let map = new MapArea();
        map.filter = WAY_FILTER; 
        map.setData(testData);
        map.radius = 500;

        let Hehn = map.waysLookup['37590936'];
        Hehn.path[Hehn.path.length-1].id = "invalid";
        
        let res = await  map.getNextOptions(Hehn);

        expect(res.length).toBe(0);
 
    } );

    test ( 'negative: roundabout ', async () => {
        let testData =  fs.readFileSync('./__testdata__/roundabout.json','UTF-8');
        const WAY_FILTER= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']
        let map = new MapArea();
        map.filter = WAY_FILTER; 
        map.setData(testData);
        map.radius = 500;

        let jervoisRoad = map.waysLookup['666019264'];
        let res = await  map.getNextOptions(jervoisRoad);

        expect(res.length).toBe(3);
        expect(res[0].roundabout).toBe('136049585')
        expect(res[0].id).toBe('666019267');    
        expect(res[1].id).toBe('666019266');
        expect(res[2].id).toBe('666019265');    
 
    } );

});



describe ( '_getPointOnLine', () => {
      

    test ( 'positive test', () => {
         
        let res = _getPointOnLine( p(0,2),p(0,0),p(0,4) );
        expect (res).toBeDefined();
        expect (res.lat).toBe(0);
        expect (res.lng).toBe(2);
    } );

    test ( 'negative: after', () => {
         
        let res = _getPointOnLine( p(0,5),p(0,0),p(0,4) );
        expect (res).toBeUndefined();
    } );

    test ( 'negative: before', () => {
         
        let res = _getPointOnLine( p(0,0),p(0,0.1),p(0,4) );
        expect (res).toBeUndefined();
    } );


    test ( 'negative: missing arguments', () => {
         
        expect( ()=> {
            let res = _getPointOnLine( p(1,2),p(0,0) );
        }).toThrow();
        
    } );

});

describe ( 'getPointCrossingPath', () => {
    let path = [];

    path.push( p(-28.637,153.603670),p(-28.638,153.603670),p(-28.639,153.603670) );
  
    test ( 'positive test', () => {
        let res = getPointCrossingPath( p(-28.6375,153.6),path );
        expect (res).toBeDefined();
        expect (res.point.lat).toBeCloseTo(-28.6375);
        expect (res.point.lng).toBeCloseTo(153.603670);
        expect (res.idx).toBe(1) 
    } );

    test ( 'positive test, point crosses path in more than once , 2nd path is closer', () => {
        let pTest = [];
        pTest.push( p(0,0),p(0,2),p(2,4) );
         
        let res = getPointCrossingPath( p(3,1),pTest ); 
        expect (res).toBeDefined();
        expect (res.point.lat).toBeCloseTo(1);
        expect (res.point.lng).toBeCloseTo(3);
        expect (res.idx).toBe(2) 
    } );

    test ( 'positive test, point crosses path in more than once , 1st path is closer', () => {
        let pTest = [];
        pTest.push( p(0,0),p(0,2),p(2,4) );
         
        let res = getPointCrossingPath( p(0.1,1),pTest ); 
        expect (res).toBeDefined();
        expect (res.point.lat).toBeCloseTo(0);
        expect (res.point.lng).toBeCloseTo(1);
        expect (res.idx).toBe(1) 
    } );


    test ( 'negative: after', () => {
         
        let res =  getPointCrossingPath( p(1,5),path );
        expect (res).toBeUndefined(); 
    } );

    test ( 'negative: before', () => {         
        let res =  getPointCrossingPath( p(-1,5),path );
        expect (res).toBeUndefined();
    } );

    test ( 'negative: missing arguments', () => {
                
        let res =  getPointCrossingPath(  );
        expect (res).toBeUndefined();

        res =  getPointCrossingPath( p(-1,5) );
        expect (res).toBeUndefined();

        
    } );

});


describe ( 'splitAtPoint', () => {

    test ( 'roundabout ', () => {
        let testData =  fs.readFileSync('./__testdata__/roundabout.json','UTF-8');
        const WAY_FILTER= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']
        let map = new MapArea();
        map.filter = WAY_FILTER; 
        map.setData(testData);
        map.radius = 500;

        let way = map.waysLookup['136049585'];
        let point = map.nodesLookup['1492975888']
        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        expect(res[0].id).toBe('136049585');
        expect(res[0].path.length).toBe(21);     
        expect(res[0].path[0].id).toBe('1492975888');     
        expect(res[0].path[20].id).toBe('1492975885');     

        expect(res[1].path.length).toBe(21);     
        expect(res[1].path[0].id).toBe('1492975888');     
        expect(res[1].path[20].id).toBe('1633441321');     

 
    } );

    test ( 'roundabout 1st point ', () => {
        let testData =  fs.readFileSync('./__testdata__/roundabout.json','UTF-8');
        const WAY_FILTER= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']
        let map = new MapArea();
        map.filter = WAY_FILTER; 
        map.setData(testData);
        map.radius = 500;

        let way = map.waysLookup['136049585'];
        let point = map.nodesLookup['1492975891']
        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        expect(res[0].id).toBe('136049585');
        expect(res[0].path.length).toBe(21);     
        expect(res[0].path[0].id).toBe('1492975891');     
        expect(res[0].path[20].id).toBe('1633441321');     

        expect(res[1].id).toBe('136049585');
        expect(res[1].path.length).toBe(21);     
        expect(res[1].path[0].id).toBe('1492975891');     
        expect(res[1].path[20].id).toBe('25841928');     
    } );

    test ( 'roundabout, oneway=no', () => {

        let way = { 
            id:"w1", tags:{ "highway": "primary","oneway": "no"},
            path:[ {id:"4"}, {id:"3"},{id:"2"},{id:"1"},{id:"4"}],
        }
        let point = { id:"3"}

        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        
        expect(res[0].id).toBe('w1');
        expect(decodePath(res[0].path)).toBe( '3,2,1,4' );     
        expect(res[0].onewayReverse).toBeUndefined();

        expect(res[1].id).toBe('w1');
        expect(decodePath(res[1].path)).toBe( '3,4,1,2' );     
        expect(res[1].onewayReverse).toBeUndefined();
    } );

    test ( 'roundabout, oneway=yes', () => {

        let way = { 
            id:"w1", tags:{ "highway": "primary","oneway": "yes"},
            path:[ {id:"4"}, {id:"3"},{id:"2"},{id:"1"},{id:"4"}],
        }
        let point = { id:"3"}

        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        
        expect(res[0].id).toBe('w1');
        expect(decodePath(res[0].path)).toBe( '3,2,1,4' );     
        expect(res[0].onewayReverse).toBeUndefined();

        expect(res[1].id).toBe('w1');
        expect(decodePath(res[1].path)).toBe( '3,4,1,2' );     
        expect(res[1].onewayReverse).toBe(true);
    } );


    test ( 'roundabout, point not included', () => {

        let way = { 
            id:"w1", tags:{ "highway": "primary","oneway": "no"},
            path:[ {id:"4"}, {id:"3"},{id:"2"},{id:"1"},{id:"4"}],
        }
        let point = { id:"5"}

        let res = splitAtPoint(way,point)

        expect(res.length).toBe(0);        
    } );


    test ( 'normal street, oneway=no', () => {

        let way = { 
            id:"w1", tags:{ "highway": "primary","oneway": "no"},
            path:[ {id:"4"}, {id:"3"},{id:"2"},{id:"1"}],
        }
        let point = { id:"3"}

        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        
        expect(res[0].id).toBe('w1');
        expect(decodePath(res[0].path)).toBe( '3,4' );     
        expect(res[0].onewayReverse).toBeUndefined();

        expect(res[1].id).toBe('w1');
        expect(decodePath(res[1].path)).toBe( '3,2,1' );     
        expect(res[1].onewayReverse).toBeUndefined();
    } );

    test ( 'normal street, oneway=yes', () => {

        let way = { 
            id:"w1", tags:{ "highway": "primary","oneway": "yes"},
            path:[ {id:"4"}, {id:"3"},{id:"2"},{id:"1"}],
        }
        let point = { id:"3"}

        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        
        expect(res[0].id).toBe('w1');
        expect(decodePath(res[0].path)).toBe( '3,4' );     
        expect(res[0].onewayReverse).toBe(true);

        expect(res[1].id).toBe('w1');
        expect(decodePath(res[1].path)).toBe( '3,2,1' );     
        expect(res[1].onewayReverse).toBeUndefined();
    } );
    test ( 'normal street, oneway undefined', () => {

        let way = { 
            id:"w1", tags:{ "highway": "primary"},
            path:[ {id:"4"}, {id:"3"},{id:"2"},{id:"1"}],
        }
        let point = { id:"3"}

        let res = splitAtPoint(way,point)

        expect(res.length).toBe(2);
        
        expect(res[0].id).toBe('w1');
        expect(decodePath(res[0].path)).toBe( '3,4' );     
        expect(res[0].onewayReverse).toBeUndefined();

        expect(res[1].id).toBe('w1');
        expect(decodePath(res[1].path)).toBe( '3,2,1' );     
        expect(res[1].onewayReverse).toBeUndefined();
    } );



});

describe ( 'isAllowed', () => {

    let map;

    beforeAll( ()=> {
        let testData =  fs.readFileSync('./__testdata__/roundabout.json','UTF-8') ;
        const WAY_FILTER= [ 'footway','service','pedestrian', 'path', 'cycleway','elevator','steps','track']
        map = new MapArea();
        map.filter = WAY_FILTER; 
        map.setData(testData);
        map.radius = 500;
    })

    test ( 'oneway - correct direction ', () => {
        let way = map.waysLookup['666019266'];
        let point = map.nodesLookup['1492975889']
        let res = isAllowed(way,point)

        expect(res).toBe(true); 
    } );

    test ( 'oneway - wrong direction ', () => {
        let way = map.waysLookup['666019266'];
        let point = map.nodesLookup['1492975880']
        let res = isAllowed(way,point)

        expect(res).toBe(false); 
    } );

    test ( 'oneway - middle', () => {
        let way = map.waysLookup['666019266'];
        let point = map.nodesLookup['4548706262']
        let res = isAllowed(way,point)

        expect(res).toBeUndefined(); 
    } );

    test ( 'oneway - point outside', () => {
        let way = map.waysLookup['666019266'];
        let point = map.nodesLookup['6235381619']
        let res = isAllowed(way,point)

        expect(res).toBeUndefined(); 
    } );

    test ( 'no oneway - correct direction ', () => {
        let way = map.waysLookup['149490336'];
        let point = map.nodesLookup['25841944']
        let res = isAllowed(way,point)

        expect(res).toBe(true); 
    } );

    test ( 'no oneway - wrong direction ', () => {
        let way = map.waysLookup['149490336'];
        let point = map.nodesLookup['4548706262']
        let res = isAllowed(way,point)

        expect(res).toBe(true); 
    } );

    test ( 'no oneway - middle', () => {
        let way = map.waysLookup['149490336'];
        let point = map.nodesLookup['1633440724']
        let res = isAllowed(way,point)

        expect(res).toBe(true); 
    } );

    test ( 'no oneway - point outside', () => {
        let way = map.waysLookup['149490336'];
        let point = map.nodesLookup['6235381619']
        let res = isAllowed(way,point)

        expect(res).toBeUndefined(); 
    } );

    test ( 'error  - way:incorrect ', () => {
        let way = '666019266';
        let point = map.nodesLookup['6235381619']
        let res = isAllowed(way,point)

        expect(res).toBeUndefined(); 
    } );

    test ( 'error  - node:incorrect', () => {
        let way = map.waysLookup['666019266'];
        let point =  '6235381619'
        let res = isAllowed(way,point)

        expect(res).toBeUndefined(); 
    } );

});



describe ( 'getCrossingInfo', () => {
      
    test ( 'positive test', () => {

        let testSet = MapArea._parse(fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8'));
        let VaseyEsplanade = testSet.waysLookup['4815077'];
        let Footway = testSet.waysLookup['184561984'];

        let res = getCrossingInfo(VaseyEsplanade,Footway);
        expect( res ).toBeDefined();
        expect( res.point.id).toBe('1941090215')
        expect( res.idx1).toBe(10);
        expect( res.idx2).toBe(4);

    } );

    test ( 'negative: streets not crossing', () => {
        let testSet = MapArea._parse(fs.readFileSync('./__testdata__/MapArea-test1.json','UTF-8')); 
        expect(testSet).toBeDefined();
        let Parking = testSet.waysLookup['183973238'];
        let Footway = testSet.waysLookup['184561984'];

        let res = getCrossingInfo(Parking,Footway);
        expect( res ).toBeUndefined()

    } );

    test ( 'negative: no arguments', () => {
        let res = getCrossingInfo();
        expect( res ).toBeUndefined()
    });
    test ( 'negative: missing 2nd arguments', () => {
        let res = getCrossingInfo( {path: [{lat:1,lng:1}]} );
        expect( res ).toBeUndefined()
    });


});







describe ( 'initialBearingTo', () => {
    test ( 'poitive', () => {
        const p1 = { lat:52.205, lng:0.119 };
        const p2 = { lat:48.857, lng:2.351 };
        let res = initialBearingTo(p1,p2); // 156.2°
        expect ( res ).toBeCloseTo(156.2,1);

    } );
    test ( 'undefined', () => {
        let res = initialBearingTo();
        expect ( res ).toBeUndefined();

    } );

});

describe ( 'alongTrackDistanceTo', () => {
    test ( 'poitive', () => {
        const p = {lat:53.2611, lng:-0.7972};
        const p1 = { lat:53.3206, lng:-1.7297 };
        const p2 = { lat:53.1887, lng:0.1334 };
        let res = alongTrackDistanceTo(p,p1,p2,6371e3); 
        expect ( res ).toBeCloseTo(62331,0);

    } );

    
    test ( 'undefined', () => {
        let res = alongTrackDistanceTo();
        expect ( res ).toBeUndefined();

    } );

});




/* Uncomment to generate some test data,This requires that also the jest.mock() call at the top of the file is un-commented
test('prep',async  () => {
        
    let location  = {lat:51.50161319206912, lng:-0.17620057086401175};
    let radius = 500;
    let onLoaded = (status,ways,mapData) => {
        console.log(status, mapData);
        fs.writeFileSync('./__testdata__/MapArea-testRoundabout.json',JSON.stringify(mapData) )    
    }
    
    let b = await new MapArea({location,radius,onLoaded} );        
    console.log(b.query);
    
    
})
*/ 



describe ( 'getVector', () => {

    test ( 'positive',   () => {
        let p1 = {lat: -16.7820535,lng: 145.6982433};
        let p2 = {lat: -16.7822514,lng: 145.6983275};
        let v1 = getVector(p1,p2);
        expect(v1.x).toBeCloseTo(8.97);
        expect(v1.y).toBeCloseTo(-22.03);
        let v2 = getVector(p2,p1);
        expect(v2.x).toBeCloseTo(-8.97);
        expect(v2.y).toBeCloseTo(22.03);

    } );

    test ( 'same point',   () => {
        let p1 = {lat: -16.7820535,lng: 145.6982433};
        let v1 = getVector(p1,p1);
        expect(v1.x).toBeCloseTo(0);
        expect(v1.y).toBeCloseTo(0);
    } );


    test ( 'no values', () => {
        expect(() => {
            getVector( );
        }).toThrowError("missing mandatory argument: p1");
    } );
    test ( 'no values', () => {
        expect(() => {
            getVector({lat: -16.7820535,lng: 145.6982433} );
        }).toThrowError("missing mandatory argument: p2");
    } );


});


describe ( '_crossing', () => {

    test ( 'positive', () => {
        let A = {lat:-28.639123, lng:153.603392};
        let B = {lat:-28.638749, lng:153.603536};
        let C = {lat:-28.638978, lng:153.603440};
        let D = {lat:-28.639190, lng:153.604172};
        let p = MapArea._crossing(A,B,C,D);

        expect(p).toBeDefined();

        let expected = {lat:-28.638985, lng:153.603446}; 
        let d = distanceBetween(p,expected)
        expect ( MapArea._isWithinRange(d) ).toBe(true);    
    } );

    test ( 'almost parallel s', () => {
        // AB =  Cavvanbah St, Byron Bay  , Australia
        // CD =  Cavvanbah Ln, Byron Bay  , Australia
        let A = {lat:-28.638421,lng:153.603670};
        let B = {lat:-28.638626,lng:153.604262};
        let C = {lat:-28.638978,lng:153.603440};
        let D = {lat:-28.639190,lng:153.604172};
        let p = MapArea._crossing(A,B,C,D);

        expect(p).toBeUndefined();
    } );

    test ( 'perfectly parallel', () => {
        let A = {lat:-28.638421,lng:153.603670};
        let B = {lat:-28.638626,lng:153.603670};
        let C = {lat:-28.638978,lng:153.603440};
        let D = {lat:-28.639190,lng:153.603440};
        let p = MapArea._crossing(A,B,C,D);

        expect(p).toBeUndefined();
    } );

    test ( 'continuation (after crossing)', () => {
        // AB =  Shirley St, Byron Bay  , Australia
        // CD =  Shirley St, Byron Bay  , Australia
        let A = {lat:-28.639573, lng:153.603225};
        let B = {lat:-28.640194, lng:153.605448};
        let C = {lat:-28.640201, lng:153.605483};
        let D = {lat:-28.640787, lng:153.607723};

        let p,d;
        p = MapArea._crossing(A,B,C,D);
        expect(p).toBeDefined();
        d = distanceBetween(p,B)
        expect ( MapArea._isWithinRange(d) ).toBe(true);    

    } );

    test ( 'A and C are the same points', () => {
        let A = {lat:-28.638985, lng:153.603446};
        let B = {lat:-28.638749, lng:153.603536};
        let C = {lat:-28.638985, lng:153.603446};
        let D = {lat:-28.639190, lng:153.604172};
        let p = MapArea._crossing(A,B,C,D);

        expect(p).toBeDefined();

        let expected = {lat:-28.638985, lng:153.603446}; 
        let d = distanceBetween(p,expected)
        expect ( MapArea._isWithinRange(d) ).toBe(true);    
    } );

    test ( 'B and C are the same points', () => {
        let A = {lat:-28.639123, lng:153.603392};
        let B = {lat:-28.638749, lng:153.603536};
        //let C = {lat:-28.638978, lng:153.603440};
        let D = {lat:-28.639190, lng:153.604172};
        let p = MapArea._crossing(A,B,B,D);

        expect(p).toBeDefined();
        let d = distanceBetween(p,B)
        expect ( MapArea._isWithinRange(d) ).toBe(true);    
    } );
    test ( 'A and D are the same points', () => {
        let A = {lat:-28.639123, lng:153.603392};
        let B = {lat:-28.638749, lng:153.603536};
        let C = {lat:-28.638978, lng:153.603440};
        //let D = {lat:-28.639190, lng:153.604172};
        let p = MapArea._crossing(A,B,C,A);

        expect(p).toBeDefined();
        let d = distanceBetween(p,A)
        expect ( MapArea._isWithinRange(d) ).toBe(true);    
    } );
    test ( 'B and D are the same points', () => {
        let A = {lat:-28.639123, lng:153.603392};
        let B = {lat:-28.638749, lng:153.603536};
        let C = {lat:-28.638978, lng:153.603440};
        //let D = {lat:-28.639190, lng:153.604172};
        let p = MapArea._crossing(A,B,C,B);

        expect(p).toBeDefined();
        let d = distanceBetween(p,B)
        expect ( MapArea._isWithinRange(d) ).toBe(true);    
    } );
    test ( 'crossing after end  of CD', () => {

        let A= { lat: -16.7822514, lng: 145.6983275 };
        let B= { lat: -16.7824429, lng: 145.6983982 };
        let C= { lat: -16.7825452, lng: 145.6983312 };
        let D= { lat: -16.7825018, lng: 145.6983486 };
        let p = MapArea._crossing(A,B,C,D);

        expect(p).toBeUndefined();

    });

})



describe( 'isRoundabout', () => {

    test( 'no roundabout',()=> {
        let w = { id:"w1", path:[
            {id:"n1",ways:["w1"]},
            {id:"n2",ways:["w1"]}
        ], tags:{highway:'secondary'} };
                
        let res = isRoundabout(w);
        expect (res).toBeFalsy();
    });

    test( 'single way roundabout, not tagged',()=> {
        let w = { id:"w1", path:[
            {id:"n1",ways:["w1"]},
            {id:"n2",ways:["w1"]},
            {id:"n1",ways:["w1"]}
        ], tags:{highway:'secondary'} };
                
        let res = isRoundabout(w);
        expect (res).toBeTruthy();
    });

    test( 'strict mode: single way roundabout, not tagged',()=> {
        let w = { id:"w1", path:[
            {id:"n1",ways:["w1"]},
            {id:"n2",ways:["w1"]},
            {id:"n2",ways:["w1"]}
        ], tags:{highway:'secondary'} };
                
        let res = isRoundabout(w,true);
        expect (res).toBeFalsy();
    });

    test( 'complex roundabout, tagged',()=> {
        let w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w2"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
        let w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n1",ways:["w1","w2"]}
        ], tags:{highway:'secondary', junction:'roundabout' }};
                
        expect ( isRoundabout(w1) ).toBeTruthy();
        expect ( isRoundabout(w2) ).toBeTruthy();
    });

    test( 'complex roundabout, not tagged',()=> {
        let w1 = { id:"w1", path:[
            {id:"n1",ways:["w1","w2"]},
            {id:"n2",ways:["w1","w2"]}
        ], tags:{highway:'secondary' }};
        let w2 = { id:"w2", path:[
            {id:"n2",ways:["w1","w2"]},
            {id:"n3",ways:["w2"]},
            {id:"n1",ways:["w1","w2"]}
        ], tags:{highway:'secondary' }};
                
        expect ( isRoundabout(w1) ).toBeFalsy();
        expect ( isRoundabout(w2) ).toBeFalsy();
    });


});

