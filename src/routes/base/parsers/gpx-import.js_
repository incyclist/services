import GXPParser from './gpx';
import {path} from '../../../../../ergo-react/src/services/app/fs'
import axios from 'axios';
import { parseInfoText,parseSegment } from './kwt';
export default async function ImportGpxImport( data, info ) {
    const parser  = GPXImportParser.getInstance();

    const url = parser.getGPXFileUrl(data,info);
    const gpx = await parser.getGPXFileContent(url);
    return await parser.import(data, gpx);  
}






export class GPXImportParser {
    static instance  = undefined;

    static getInstance() {
        if (!GPXImportParser.instance) {
            GPXImportParser.instance = new GPXImportParser();
        }
        return GPXImportParser.instance;
    }

    getGPXFileUrl(data,info) {
        if (!data['gpx-file-path'])
            throw new Error('<gpx-file-path> is missing');

        if (!info || info.type!=='url')
            throw new Error('unsopported mode');

        let inputUrl = info.url;
        let gpxFile = data['gpx-file-path'][0];

        
        const regex = /(\\|\/)/g;


        if (gpxFile.search(regex)===-1) {
            
            if (  inputUrl.startsWith('incyclist:') || inputUrl.startsWith('file:')) {
                const parts = inputUrl.split('://');
                const gpxPath = parts[1].replace(info.name,gpxFile)
                gpxFile = `incyclist://${gpxPath}`
            }

        }
        else {
            // relative path
            if ( gpxFile.startsWith('.') ) {
                //videoFile = joinPath( info.dir, videoFile, delimiter)
                const gpxPath = path.join( info.dir, gpxFile)
                gpxFile = `incyclist://${gpxPath}`
            }
            else {
                gpxFile = `incyclist:///${gpxFile}`;                                            
            }
        }

        return gpxFile;
    }

    async getGPXFileContent(url) {
        const res = await axios.get(url)
        return res.data;
    }

    async import( data, gpxFileContent) {
        const get = (key) => {
            let item = data[key] ? data[key][0]: undefined
            if (typeof(item)==='object') {
                item = item.$
            }
            return item;
        }
    
        // parse GPX Data
        const routeObj = await GXPParser.import(gpxFileContent,{original: true});


        const route = routeObj.get();

        route.title = data.title? data.title[0] : data.name? data.name[0] : 'Unknown';
        route.localizedTitle = data.title[0] ? data.title[0].$: data.name? data.name[0] : undefined;
        route.routeId = get('id')
        route.country = get('country')
        route.author = undefined;
        route.private = true;

        if (!data.framerate)
            throw new Error('<framerate> is missing');
        if (!data['video-file-path'])
            throw new Error('<video-file-path> is missing');

        route.video = {}
        route.video.file = data['video-file-path'][0]
        route.video.framerate = Number(data.framerate[0]);
        route.video.informations = data.informations;
        route.video.next = get('next-video')

        if ( data.informations && data.informations[0] && data.informations[0]!=='' && data.informations[0].information ) 
            route.infoTexts = data.informations[0].information.map(s=>parseInfoText(s.$));
        if ( data.segments && data.segments[0] && data.segments[0]!=='' && data.segments[0].segment ) 
            route.selectableSegments = data.segments[0].segment.map(s=> parseSegment(s.$));


        const fileParts = route.video.file.split('.');
        const extension = fileParts[fileParts.length-1];            
        if (extension.toLowerCase()==='mp4') {
            route.video.format = 'mp4';
        }
        
        route.video.mappings =  route.decoded.map( (p,idx) => {
            const m = {}
            m.time = p.time
            if (idx!==route.decoded.length-1) {
                    m.videoSpeed = (route.decoded[idx+1].routeDistance-p.routeDistance)/(route.decoded[idx+1].time-p.time)*3.6;                
            }
            else {
                m.videoSpeed = route.decoded[idx-1].videoSpeed
            }
            m.distance = Math.round(p.routeDistance);
            m.frame = Math.round(p.time*route.video.framerate);
            delete p.time;
            return m;
            
        })


        if ( data.smooth ) {
            const smoothCfg = data.smooth.map( s =>  typeof s === 'object' ? { repeat:s.$.repeat, value: Number(s._||10)} : { repeat:1, value: Number(s||10) } );
            
            const fnElevationAverage = routeObj.elevationRollingAverage.bind(routeObj);       
            smoothCfg.forEach( (s) => { 
                let repeat = s.repeat;
                while (repeat--) {
                    routeObj.smooth( {range: s.value, method:fnElevationAverage})
                }

            });
        }


        return route;
    }
    
}