import {parseString} from 'xml2js';
import { EventLogger } from 'gd-eventlog';
import RouteUtils  from '../../../../../ergo-react/src/models/route/RouteUtils'
import { addVideoSpeed, toXml } from './utils';

let _logger;

export default class EPMParser {

    static async import( data ) {
        let epm;
        let epp;

        return new Promise( async (resolve,reject) =>  {        

            data.forEach(element => {
                if (element.format.toLowerCase()==='epm') 
                    epm = element.data;
                if (element.format.toLowerCase()==='epp') 
                    epp = element.data;
            });

            if (epm===undefined) 
                return reject( "Missing EPM File");      

            if (epp===undefined) 
                return reject( "Missing EPP File");      
            
            var route = {};
            try {
                route = await parseEpm(epm,route);
                route = await parseEpp(epp,route);
                

                resolve( RouteUtils.validateData(route));    
            }
            catch (err) {
                reject(err);
            }

            
        });
    }
}

export function createNoGpxRouteFromEpmEpp(route) {
    if (route===undefined || route.epp===undefined || !route.gpxDisabled )
        return;
    
        /*  {lat: -16.7822318,lng: 145.6982588,elevation: 18,distance: 0,routeDistance:0,slope: -2.1}, */
    route.decoded = route.epp.programData.map( p =>  ({ routeDistance:p.distance, elevation:p.elevation}))
}

export function combineEpmWithEpp(route) {
    if (route===undefined || route.decoded===undefined || route.epp===undefined || route.epp.programData===undefined)
        return;
    
    if ( route.gpxDisabled) {
        return;
    }

    var j=0;
    let prevElevation = 0;
    let prevDistance = 0;
    let prevSlope = 0;
    
    // add elevation data
    for (var i=0;i<route.decoded.length;i++) {
        if (i===0) {
            route.decoded[i].elevation = route.epp.programData[j].elevation;
            prevElevation = route.decoded[i].elevation;
            prevSlope = route.decoded[i].slope
        }
        else {
            while(j<route.epp.programData.length && route.decoded[i].routeDistance > route.epp.programData[j].distance)
                j++;
            
             
            if (j<route.epp.programData.length) {
                let distance =  route.epp.programData[j].distance - prevDistance;
                let gain = route.epp.programData[j].elevation - prevElevation;
    
                if ( distance!==0) {
                    let gainToPoint = gain/distance*(route.decoded[i].routeDistance-prevDistance);
                    let distToPoint = route.decoded[i].routeDistance-prevDistance;
                    route.decoded[i].elevation = prevElevation+gainToPoint;
                    route.decoded[i-1].slope = gainToPoint/distToPoint*100;
                }
                else {
                    route.decoded[i].elevation = prevElevation;
                }
                prevDistance = route.decoded[i].routeDistance;
                prevElevation = route.decoded[i].elevation;    
                prevSlope = route.decoded[i].slope;    
            }
            else {
                route.decoded[i].slope = prevSlope;
                const distToPoint = route.decoded[i].routeDistance-prevDistance;
                const gainToPoint = prevSlope/100*distToPoint;
                route.decoded[i].elevation = prevElevation+gainToPoint;

            }
            
            
        }
    }

    // add video speed data
    addVideoSpeed(route)
    return route;
}

export async function parseEpm( data, route ) {
    return new Promise( async (resolve,reject) =>  {        
        parseString(data, (err,result)=> {
            if (err) return reject((err && err.message) ? err.message.replace(/\n/g,' ') : err);
            
            if(result===undefined || result.roadmovie===undefined) 
                return reject ("Could not parse EPM File");


            if (route===undefined) route = {};
            route.title = result.roadmovie.name[0];
            route.distance = 0.0;
            route.decoded = [];
            route.elevation = 0;
            route.author = undefined;
            route.private = true;
            route.routeId = result.roadmovie.id[0];

            if(result.roadmovie.positions===undefined || result.roadmovie.positions[0]==='' ||result.roadmovie.positions[0].position===undefined)
                route.gpxDisabled = true;

            let prevDistance = undefined;
           
            
            if (!route.gpxDisabled ) {
                let positions = result.roadmovie.positions[0].position;
                for (var i=0;i<positions.length;i++) {
                    let pos = positions[i].$;

                    if (typeof pos.lat ==='string' && pos.lat.includes(',') &&!pos.lat.includes('.') )
                        pos.lat = pos.lat.replace(',','.')
                    if (typeof pos.lon ==='string' && pos.lon.includes(',') &&!pos.lon.includes('.') )
                        pos.lon = pos.lon.replace(',','.')
                    if (typeof pos.distance ==='string' && pos.distance.includes(',') &&!pos.distance.includes('.') )
                        pos.distance = pos.distance.replace(',','.')


                    let point = { 
                        lat:Number(pos.lat), 
                        lng:Number(pos.lon),
                        routeDistance:Number(pos.distance),
                        elevation:Number(pos.height),
                        slope:0
                    }

                    if (prevDistance===undefined) {
                        point.routeDistance = 0;
                        point.distance=0;
                        prevDistance = 0;
                    }
                    else {                        
                        point.distance = point.routeDistance-prevDistance;
                        prevDistance = point.routeDistance;
                    }
                    route.distance = point.routeDistance;
                    
                    route.decoded.push( point );
                    
                }
            }

            route.video = {}
            route.video.file = result.roadmovie['video-file-path'][0]
            route.video.framerate = parseFloat(result.roadmovie.framerate[0]);
            route.video.width = parseInt(result.roadmovie.width[0]);
            route.video.height = parseInt(result.roadmovie.height[0]);
            route.video.segments = result.roadmovie.segments;
            route.video.informations = result.roadmovie.informations;
            route.video.next = result.roadmovie['next-video'] ? result.roadmovie['next-video'][0] : undefined

            const fileParts = route.video.file.split('.');
            const extension = fileParts[fileParts.length-1];            
            if (extension.toLowerCase()==='mp4') {
                route.video.format = 'mp4';
            }

            if ( result.roadmovie.mappings ) {
                const mappings = result.roadmovie.mappings[0].mapping;
                let prev;
                let prevTime =0;
                route.video.mappings = [];

                const startFrame = result.roadmovie['start-frame'] ? parseInt(result.roadmovie['start-frame'][0]) : 0;
                const endFrame = result.roadmovie['end-frame'] ? parseInt(result.roadmovie['end-frame'][0]) : undefined;
                
                try {

                    const getDistance = (mapping,prevMapping,idx) => {
                        const prevDist = prevMapping.distance || 0;
                        const prevFrame = prevMapping.frame || startFrame;
                        if (mapping.distance!==undefined)
                            return mapping.distance;
                        if (prev.dpf!==undefined && mapping.frame!==undefined)
                            return  prev.dpf*(mapping.frame-prevFrame)+prevDist
                        throw new Error(`mapping #${idx}: one of [distance], [dpf or frame] is missing: <mapping ${toXml(mapping) }/>`)
                    }


                    mappings.forEach ( (m,idx) => {
                        if (idx!==0) {
                            const mapping = m.$
                            
                            
                            mapping.distance = (mapping.distance!==undefined && mapping.distance!==null) ? parseInt(mapping.distance) : undefined;
                            mapping.dpf = (mapping.dpf!==undefined && mapping.dpf!==null) ? parseFloat(mapping.dpf) : undefined;
                            mapping.frame = (mapping.frame!==undefined && mapping.frame!==null) ? parseInt(mapping.frame) : undefined
    
    
                            const distance = getDistance(mapping,prev,idx)
                            //if (idx===1) console.log(distance,prev,mapping)
                            route.distance = mapping.distance = distance;

                            const frames = mapping.frame-(prev.frame||startFrame);
                            const videoSpeed = (prev.distance===undefined && mapping.dpf!==undefined) ? 3.6*mapping.dpf* route.video.framerate : 3.6 * (distance-prev.distance) / frames * route.video.framerate
                            const time = prevTime + frames/route.video.framerate ;
                            route.video.mappings.push ( { videoSpeed,time:prevTime, ...prev})
                            //if (idx<10) console.log(frames,prev, { videoSpeed,time,endFrame:mapping.frame, ...prev})
                            prev = mapping;
                            prevTime = time;
                            
    
                            if ( idx===mappings.length-1) {
                                route.video.mappings.push ( { videoSpeed, time,...mapping})
                            }
    
                        }
                        else {
                            const mapping = m.$
                            mapping.distance = (mapping.distance!==undefined && mapping.distance!==null) ? parseInt(mapping.distance) : undefined;
                            mapping.dpf = (mapping.dpf!==undefined && mapping.dpf!==null) ? parseFloat(mapping.dpf) : undefined;
                            mapping.frame = (mapping.frame!==undefined && mapping.frame!==null) ? parseInt(mapping.frame) : undefined


                            prev = mapping
                            prevTime = 0;
    
                        }
                    })

                    if ( endFrame && prev.dpf!==undefined) {
                        const mapping  = {frame:endFrame, dpf:prev.dpf};
                        
                        route.distance = getDistance(mapping,prev);

                    }
                    route.distance = parseInt(route.distance)
                    //console.log( route.video.mappings.map( (m) => `${m.frame} ${m.videoSpeed} ${m.distance}` ))
    
                }
                catch(err) {
                    if (!_logger) _logger = new EventLogger('EpmParser');
                    _logger.logEvent({message:'epm details',error:err.message, clipmapper:result.roadmovie.clipmapper,mappings});
                    return reject( 'Could not parse EPM File' );
                }
                 
            }




            resolve(route);
        });
    });
}

class BinaryReader {
    constructor (data) {
        this.data = data;
        this.pos =0;
        this.buffer = Buffer.from(this.data);
        this.length = data.length;
    }

    
    
    setPosition(pos) {
        this.pos = pos;
    }

    ReadBytes(cnt) {
        let bytes = [];

        for(var i=this.pos;i<this.data.length && i<this.pos+cnt;i++) {
            let s= this.data[i].charCodeAt(0);
            bytes.push(s)
        } 
        this.pos = i;
        return bytes;
    }

    ReadUint32() {
        /*
        let val =  this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        */
        let bytes = this.ReadBytes(4);
        let val = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
        return val;
    }

    ReadUint16() {
        let bytes = this.ReadBytes(2);
        let val = bytes[0] | (bytes[1] << 8) ;
        return val;
    }

    ReadFloat() {
        var view = new DataView(new ArrayBuffer(4))

        let j=0;
        for(var i=this.pos;i<this.data.length && i<this.pos+4;i++) {
            let s= this.data[i].charCodeAt(0);
            view.setUint8(3-j,s);
            j++;
        } 
        this.pos = i;
        return view.getFloat32();
    }

    ReadInt32() {
        return this.ReadUint32();
        /*
        let val =  this.buffer.readInt32LE(this.pos);
        this.pos += 4;
        return val;
        */
    }

    ReadString(cnt) {

        let str='';
       
        for(var i=this.pos;i<this.data.length && i<this.pos+cnt;i++) {
            let s= this.data[i];
            if (s.charCodeAt(0)!==0)
                str = str+this.data[i];
        } 
        this.pos = i;
        return str;
        
    }

}

function getV7Program(reader,json) {
    var num = (reader.length-388)/12;

    reader.ReadString(4);
    json.min = reader.ReadUint32();
    json.max = reader.ReadUint32();
    json.cnt =  reader.ReadUint32();
    if (json.cnt!==num) {
        throw new Error('Invalid program event count ('+json.cnt+' != '+num+')');
    }
    json.sampleRate =  reader.ReadUint32();
    json.validFor = reader.ReadUint32();  //BITs: 1: bike, 2: lyps, 4: run
    json.elevationStart = reader.ReadFloat();
    json.powerLimit = reader.ReadUint16();
    json.hrmLimit = reader.ReadUint16();
    json.speedLimit = reader.ReadFloat();
    reader.ReadString(8);
    json.programData = [];
    let distance = 0;
    for ( var i= 0; i<num; i++ ) {
        let sampleRate = reader.ReadUint32();
        let value = reader.ReadFloat();
        let _ignore = reader.ReadFloat();
        if ( sampleRate === json.sampleRate) {
            json.programData.push({elevation:value, x:_ignore, distance});
            distance+=json.sampleRate;
        }
    }
}

function getV6Program(reader,json) {
}



export async function parseEpp( data, route ) {
    return new Promise( async (resolve,reject) =>  {        

        var json = {};
        if (route===undefined)
            route = {};
        const reader = new BinaryReader(data);

        json.header =reader.ReadString(8);
        //console.log(json.header)
        if (json.header!=='EW2_EUP ')
            return reject ('Invalid File Header');

        json.version = reader.ReadUint32();
        if (json.version!==7 && json.version!==6)
            return reject ('Invalid File Version '+json.version);

        try {
            const dateLow = reader.ReadInt32();
            const dateHigh = reader.ReadInt32();
            json.time =  (dateHigh << 32) +dateLow;
            json.name = reader.ReadString(64).toString();
            json.description = reader.ReadString(256);
            json.programType = reader.ReadUint32(); 
    
            if (json.version===7)
                getV7Program(reader,json);
            if (json.version===6)
                getV6Program(reader,json);    
        }
        catch (err) {
            reject(err);
        }
        route.epp = json;
 
        if ( route.gpxDisabled)
            createNoGpxRouteFromEpmEpp(route)
        else
            combineEpmWithEpp(route);
            
        resolve(route);
    });
}